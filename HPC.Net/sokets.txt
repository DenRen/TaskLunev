Полезные ссылки:
    1) http://www.lib.ru/unixhelp/network.txt

1.1) Введение

Протокол   - соглашение о порядке взаимодействия программ
Веб-сервер - обычное рассматривается как daemon.
Веб-клиент - браузер.

Иногда нужно использовать поддежрку асинхонного обратного вызова (async callback)

Клиент <---- Канал связи ----> Сервер

Стек протоколов TCP/IP - набор протоколов Интернета

Клиент <--------v
Клиент <------> Сервер
Клиент <--------^

Клиенты и серверы используют протокол управления передачей (Transmission Control Protocol, TCP),
TCP использует протокол Интеренета (IP), а IP устанавливает соединение с протоколом канального
уровня.

Веб-клиент                 Веб-клиент               Уровень приложений
    ^                           ^
    |                           |       
    v                           v   
   TCP                         TCP                  Траснпортный уровень
    ^                           ^
    |                           |                   
    v                           v      
    IP                          IP                  Сетевой уровень
    ^                           ^
    |                           |           
    v                           v       
Драйвер Ethernet  ------   Драйвер Ethernet         Канальный уровень

Протокол управления передачей (Transmission Control Protocol, TCP)
Протокол пользовательских дейтаграмм (User Datagram Protocol, UDP)

Локальная  сеть - Local Area Network, LAN
Глобальная сеть - Wide  Area Network, WAN   (Через маршрутизаторы)

1.7) Модель OSI:                Набор протоколов Интернета
    1) Уровень приложения       // Модель приложения
    2) Уровень представления    // *
    3) Уровень сеанса           // *

    4) Траснпортный уровень     // TCP, , UDP
    5) Сетевой уровень          // IPv4, IPv6

    6) Канальный уровень        // Аппаратное обеспечение драйверов
    7) Физический уровень       // устройств и сетей

Максимальная единица трансляции (MTU): 1500 байт
TCP, UDP, SCTP
Можно использовать IPv4 и IPv6 непосредственно: 
    Символьные сокеты (raw socket)

Определение топологии сети:
    netstat, ifconfig

Административный каталог: /sbin, /usr/sbin

2. Транспортный уровень

Протокол управления передачей потоков (Stream Control Transmission Protocol, SCTP)

Трёхэтапное рукопожатие TCP
Последовательность прерывания соединения TCP
Состояние TCP (TIME_WAIT)
Четырёхэтапное рукопожатие и завершение соединения SCTP
Буфуризация TCP, UDP и SCTP уровнем сокетов
Т.д.

BPF - BSD Packet Filter
DLPI - Data Link Provider Interface

Linux предоставляет доступ к канальному уровню при помощи
специального типа сокетов SOCK_PAKET

Разные проги: tcpdump, ping, traceroute

    1) IPv4 предоставляет сервис пакетов для TCP, UDP, SCTP, ICMP и IGMP
    1) IPv6 предоставляет сервис пакетов для TCP, UDP, SCTP, ICMPv6
    3) Проотокол управления передачей. TCP: IPv4, IPv6
    4) UDP: Протокол пользовательских дейтаграмм. IPv4, IPv6
    5) SCTP: Протокол управления передачей потоков. двусторонняя ассоциация
        Несколько IP-адресов и один порт для каждой стороный соединения.
        Есть сообщения. Одновременно может использовать IPv4 и IPv6
    6) ICMP: Протокол управляющих сообщений Интернета. 
        Обеспечение передачу управляющей информации и сведений об ошибках между
        маршрутизаторами и узлами
    7) IGMP: Протокол управления группами Интернета.
        Используется для многоадресной адресации
    8) ARP: Протокол разрешения адресов.
        Ставит соотв. аппаратному адресу (напр. Ethernet) адрес IPv4
    9) RARP: Протокол обратного разрешения адресов.
        Ставит соотв. адресу IPv4 аппаратномый адрес (напр. Ethernet) 
    10) BPF: Фильтр пакетов BSD. Предоставл. доступ к канальному уровню дял процесса
    11) DLPI: Интерфейс провайдера канального уровня.
        Предоставляет доступ к канальному уровню

Приложение записывает в сокет дейтаграмму (datagram), которая инкапсулируется (encapsulate)
(упаковывается) в дейтаграмму IPv4, либо в IPv6. UDP - не гарантирует, что дойдёт сообщение.

UDP - имеет конкретную длину дейтаграммы, т.е. рассм. как запись (record)
TCP - является потоковым (byte-stream) протоколом, без каких-либо границ записей (отличие от UDP)

TCP устанавливает соединение (connection) и обеспечивает надёжность reliability()

TCP динамически прогназирует время (период) обращения (round-trip time, RTT) между клиентом и 
сервером. TCP постоянно пересчитывает RTT.
TCP упорядочивает данные, связывая некоторый порядковый номер с каждым отправленныйм им байтом

Сегмент (segment) - это блок данных, передаваемых протоколом TCP протоколу IP.
TCP игнорирует дублированные данные (определяет их по номерам байт)

TCP обеспечивает управление потоком (flow control). TCP всегда сообщает своему собеседнику,
сколько именно байтов он хочет получить от него. Это называется объявлением окна (window).
В любой момент времени окно соответствует свободному пространству в буфере получателя. Размер
окна изменяется динамически и может обнулиться, при этом отправитель должен подождать, когда
приложение считает данные из буфера.

TCP является двусторонним (full-duplex)

SCTP: ассоциация означает взаимодействие двух систем, которые могут иметь по несолько адресов.
Это называет multihomig - множественная адресация.
SCTP, как и UDP, передаёт сообщения и их размер.
SCTP из-за множественной адресации обеспечивается дополнительная устойчиваость в случае отказа 
сети. (Для TCP такое тоже можно реализовать, если использовать протоколом маршрутизации BGP.
BGP соединение внутри домена (iBGP) часто используют адреса, назчнаемые виртуальному интерфейсу
маршрутизатора в качестве конечных точек соединения TCP.
Протокол маршрутизации домена гарантирует, что если между двумя маршрутизаорами будет хоть
какой-то досупный путь, он будет использован, что было бы невозможно, если бы испольлзуемые
адреса принадлежали интерфейсу сети, где возникли проблемы)

2.6) Установление и завершение соединения TCP

Трёхэтапное рукопожатие
    1) Сервер должен быть готов принять входящее соединение. (socket, bind, listen)
       Это называется пассивное открытие (passive open)
    2) Клиент выполняет активное открытие (active open) вызывая connect. Это заставляет
       клиента TCP послать сегмент SYN, чтобы сообщить серверу начальный порядковый номер
       данных, которые клиент будет посылать по соединению. Обычно с сегментом SYN не
       посылается никаких данных: он содержит только заголовок IP, заголовок TCP, и возможно
       параметры TCP.
    3) Сервер должен подтвердить получение клиентсокго сегмента SYN, а также должен послать
       свой собственный сегмент SYN, содержащий начальный порядковый номер для данных, которые
       сервер будет посылать по соединению.
       Сервер посылает SYN и ACK - подтверждение приёма клиентского SYN - в виде единственного
       сегмента. (ACK - acknowledgement)
    4) Клиент должен подтвердить получение сегмента SYN сервера.

Параметры TCP
    1) MSS (max segment size) узел, отпр-ий. SYN, объявляет макс. кол-во данных, которое он
       будет принимать в каждом сегменте TCP на этом соединеии. TCP_MAXSEG
    2) Параметр масштабирования окна (Window scale option). Сдвигает максимальный рамер окна,
       который может быть установлен в заголовке TCP (max = 65 535), влево на 0-14 разрядов.
       Т.е. предоставляя макс. возможное окно рамером 65536 * 2^14 ~ 1Гбайт. SO_RCVBUF
    3) Временная метка (Timestamp option)

Завершение соединения TCP
    1) Приложение вызывает close (конечная точка TCP выполняет активное закрытие (active close))
       TCP этого узла отправляет сегмент FIN, обознач. прекращение передачи
    2) Узел, получающий FIN, выполняет пассивное закрытие (passive close). Полученный FIN
       подтверждается TCP (с помощью ACK). Получение FIN передаётся приложению как признак конца
       файла.
    3) Приложение, получившее признак конца файла, вызывает close. При этом его TCP отправляет
       сегмент FIN.
    4) TCP системы, получающий окончательный FIN (где произошло активное закрытие), подтверждает
       получение FIN.

Вложенное подтверждение (piggybacking)

2.7) Состояние TIME_WAIT

Продолжительность TIME_WAIT равна двум MSL (maximum segment lifetime - макс. время жизни сегмента)
MSL - это макс. кол-во времени, в течении которого дейтаграмма IP может оставаться в сети.
Каждая дейтаграмма содержит 7-разрядное поле предельного кол-ва прыжков (hop limit)
Могут возникать пелти маршрутизации. Покет, который блуждает по сети больше MSL, называется
потерянной копией или дубликатом (lost duplicate), а также блуждающей копией (wandering).
TCP обрабатывает эти дублированные пакеты.

    Если в новом соединении IP-адреса и порты те же, что и в только что закрытом, то новое
называется воплощениемм (incarnation)

2.9) Номера портов
UDP, TCP, SCTP различают процессы при помощи 16-разрядныз целых чисел - номеров портов.
Группа заранее известных портов (well-known ports). Динамически назначаемые, или эфемерные
(ephemeral) (т.е. с непродолжительным временем жизни).

IANA (Internet Assigned Numbers Authority):
    1) Заранее известные порты: 0 - 1023
    2) Зарегестрированные порты: 1024 - 49151
    3) Динамические, или частные порты: 49152 - 65535

Пара сокетов:
    1) локальный IP, локальный порт TCP
    2) удалённый IP, удалённый порт TCP 

3) Введение в сокеты

inet_addr, inet_ntoa - для IPv4
inet_pton, inet_ntop - для IPv4 и IPv6

Универсальная структура адреса соекта: struct sockaddr;

Аргумент типа "значение-результат" (value-result argument)
Способ, которым передаётся длина, зависит от направления, в котором передаётся структура адреса:
    1) от процесса к ядру: bind, connect и sendto
        struct sockaddr_in serv;
        /* Заполняем serv {} */
        connect (sockfd, (SA*) &serv, sizeof (serv));
    2) от ядра к процессу: accept, recvfrom, getsockname и getpeername
        struct sockaddr_un cli;
        socklen_t len;
        len = sizeof (cli);
        getpeername (unixfd, (SA*) &cli, &len);
        /* Значение len могло измениться */

3.4) Функции определения порядка байтов

    htons, htonl, ntohs, ntohl

Способ упорядочивания байтов в конкретной системе называется порядком байтов узла (host byte order)
В сетевых протоколах используется сетевой порядок байтов (network byte order).
Протоколы Интернета используют обратный порядок байтов (big-endian).

3.5) Функции управления байтами

    bzero, bcopy, bcmp

3.6) Функции inet_aton, inet_addr и inet_ntoa
    inet_addr - считается устаревшей

3.7) Функции inet_pton, inet_ntop
    family = AF_INET, AF_INET6
    len = INET_ADDRSTRLEN, INET6_ADDRSTRLEN

4) Элементарные сокеты TCP

Условия, при которых генерируется RST:
    1) сегмент SYN приходит для порта, не имеющего прослушающего сервера
    2) TCP хочет разорвать существующее соединение
    3) TCP получает сегмент для несуществующего соединения

IN6ADDR_ANY_INIT
getsockname

4.6) accept - вызывается сервером TCP для возвращения следующего установленного соединения
из начала очереди полностью установленных соединений или блокируется в их ожидании.
Прослушиваемый сокет (listening socket)
Присоединённый сокет (connected socket)

Аргумент типа "значение-результат": int* len // Передаём значение по указатели и через него ответ

4.8) Параллельные серверы
    В просто м случае делаются через fork. Самое главное не забывать, что при нём дублируются
    файловые дескрипторы и вызывать close нужно как в дочернем, так и в родительском процессе.

4.9) close
    TCP пытается отправить данные, которые уже установлены в очередь, и после их отпарвки 
    нормально закрывает соединение TCP.
    Параметр сокета: SO_LINGER - позволяет изменять последовательность закрытия сокета TCP.

    shutdow отправляет FIN по соед. TCP

4.10) getsockname и getpeername - возвращают либо локальный, либо удалённый адрес протокола,
    связанный с сокетом.
    MAXSOCKADDR

5) Пишем и анализируем Эхо-сервер TCP

Если используется fork для последующей работы с клиентом, то нужно не забывать, что при
завершении дочернего процесса, он остаётся в состоянии зомби => кушает дескриптор, которых мало.
Нужно этих зомби истреблять. Это делается перехватом сигнала SIGCHILD и вызовом wait в обработчике.

5.9) Медленный системный вызов (slow system call) - системный вызов, который может быть
заблокирован навсегда. 
Поддержка флага SA_RESTART не является обязательной, поэтому нужно ловить EINTR при блокировке
медленных функций.
Есть функция, которую мы не можем перезапустить самостоятельно (перехватом errno): connect.
При её перезапуске она немедленно выдаст ещё одну ошибку. Когда функция connect прерывается
перехваченным сигналом и не перезапускается автоматически, нужно вызывать select, чтобы
дождаться завершения соединения.

5.10) wait и waitpid
WIFEEXITED и WEXITSTATUS
WHOHANG для waitpid (options) - сообщает ядру, что не нужно выполнять блокирование, если нет
завершённых процессов.

Выводы:
    1) При выполнении функции fork, следует перехватывать сигнал SIGCHILD.
    2) При перехватывании сигналов мы должны обрабатывать прерванные системные вызовы.
    3) Обработчик сигналов SIGCHILD должен быть создан корректно с использованием функции
       waitpid (-1, &stat, WHOHANG), чтобы не допускать появления зомби

5.12) Завершение процесса сервера
    Если убить дочерний процесс сервера, когда клиент будет в заблокированном состоянии от fgets,
    то клиент пропустит FIN от сервера и последующие действия будут не совсем правильными. Дело в
    том, что клиент блокируется сразу от двух файловых дескрипторов: сокет и stdin.

5.13) SIGPIPE
    Когда процесс произваодит запись в сокет, получивший сегмент RST, процессу посылается SIGPIPE.
    (Действие по умолчанию у SIGPIPE - Treminate). Операция аписи возвращает EPIPE.

5.14) Сбой на узле сервера
    Отрубают серевер, отправляют сообщение и ждут readline. TCP осуществляет повторные передачи.
    1) Если на узле сервера произошёл сбой, и на все сегменты данных клиента не было ответа,
       будет возвращена ошибка ETIMEOUT.
    2) Если некий промежуточный маршрутизатор определил, что узел сервера был недоступен, и
       ответил сообщением ICMP о недоступности получателя, клиент получит лиибо ошибку
       EHOSTUNREACH, либо ошибка ENETUNREACH.
5.15) Сбой и перезагрущка на узле сервера
    (SO_KEEPALIVE)
    readline при получении клиентом RST возвратит ошибку ECONNRESET

5.17) Итоговый пример TCP
    Сервер: accept вовращает удалённый адрес, getsockname локальный

5.18) Формат данных
    Если передавать текстовые строки между сервером и клиентом, то все результаты на любых
    архитектурах будут верными.
    Но если передавать двоичные структуры между системами с разными архитектурами (BE и LE), то
    могут возникуть проблемы: число передаётся через сокет в прямом порядке, а на сервере
    интерпретируются в обратном. Можно заметить эту проблему, если передавать не числа 15, 98,
    а отрицательные: -45, -36. Результат их суммы будет неопределён на разных архитектурах.

    Нужно корректно указывать тип данных. Я предполагаю, что имелось в виду вместо long,
    использовать int64_t и как-то решать проблему интерпретации BE и LE.

6) Мультеплексирование ввода-вывода: select и poll
    * блокируемый ввод-выовд
    * неблокируемый ввод-выовд
    * мультеплексирование ввода-вывода (select, poll)
    * ввод-вывод, управляемый сигналом (SIGIO)
    * асинхронный ввод-вывод (функции POSIX aio_)

    В TCP есть переменная: минимальный объём данных в сокете (low water-mark)

    recvfrom
    В неблокирующем режиме recvfrom в цикле опрашивает сокет (EWOULDBLOCK).
    Называется опрос (polling).

6.3) Select
    Аргумент excepset определяет дескрипторы на наличие исключений:
    1) На соект приходят внеполосные данные
    2) Control status information, которая должна быть счтиана с управляющего (master side)
    fd_set rset;
    FD_ZERO (&rset);    // Init set
    FD_SET (1, &rset);  // Set bit for 1

    Можем во все три аргумента (w, r, e) поставить NULL и получить таймер высокой точности)
    FD_SETSIZE
    nfds нужно устанавливать 1 больше, чем мах номер fd (0, 1, 2, 4, 5 => nfds = 6)
    getsockopt с параметром SO_ERROR // Сост. ошибки будет сброшено
    SO_DNSLOWAT
    Когда происходит ошибка на сокете, select отмечает его готовым как для read, так и для write

    ВАЖНО! select ничего не знает о буфере станартного ввода, поэтому fgets может прочитать строку,
    затем снова уйти в select и заблокироваться, хотя в буфере stdin есть ещё и другие уже готовые
    строки. Использовать select и fgets вместе опасно!

6.6) shutdown. SHUT_RD, SHUT_WR, SHUT_RDWR
6.10) poll
    pselect даёт возможность заблокировать сигналы, в отличие от select и poll

7) Параметры сокетов

7.2) getsockopt, setsockopt
    Последний аргумент getsockopt - "знаечние-результат"

    SO_LINGER. Если узел сервера выйдет из строя перед тем, как приложение-сервер считает
    оставшиеся данные, клиентское приложение никогда не узнает об этом. Клиент может установить
    параметр сокета SO_LINGER, задав некоторое положительное время задержки

    Очень много подробного описания параметров на 240-ой странице

7.9) Параметры сокетов TCP
    TCP_MAXSEG, TCP_NODELAY (отключает алгоритм Нагла)
    Назначение лгоритма Нагла - сократить число небольших пакетов в глобальной сети

    SO_SNDBUF, SO_RCVBUF

    Бывает клиент, которому нежелательно использовать Нагла и задержанных ACK TCP.
    writev - лучшее решение, нежели два write

8) Основные сведения о сокетах UDP

8.2) recvfrom, sendto
    SO_RCVBUF

    sendto - дейтаграмма была добавлена к очереди вывода канального уровня

8.8) Проверка полученных ответов
    Представим, что мы клиент, который вызвал recvfrom, и сравнивает адрес отправителя с адресом
    сервера, куда раньше отправил данные. Если они не равны, то игнорирует сообщение.
    Это будет работать только в том случае, когда IP адрес у сервера один, но когда его два, то
    можем отправлять сообщение по одному IP, а возвращать ответ сервер имеет право и по другому
    IP. Ответ нашего сервера мы в итоге проигнорим.


    Информация, доступная серверу из приходящей дейтаграммы IP:

    IP-дейтаграмма клиента      TCP-сервер      UDP-сервер
    --------------------------------------------------------
    IP-адрес отправителя        accept          recvfrom
    Номер порта отправителя     accpet          recvfrom
    IP-адрес получателя         getsockname     recvmsg
    Номер потра получателя      getsockname     getsockname

    Для того, чтобы вызвать recvmsg, нужно установить параметр сокета IP_RECVDSTADDR для IPv4 или
    IPV6_PKTINFO для IPv6

8.11) connect для UDP
    Мы можем сделать присоединённый сокет UDP, вызвав connect для него.
    Это нужно для обработки асинхронных ошибок, которые не вовзращаются
    неприсоединённым UDP сокетам.

    Можно повторно вызвать connect, чтобы 
        1) Задать новый IP-адрес и порт
        2) Отсоединить сокет (sin_family -> AF_UNSPEC)

    Если по UDP нужно отправлять только одному собеседнику, то лучше присоединить UDP сокет.
    Это сэкономит треть времени, т.к. в некоторых реализациях отправка сообщения - это 
    временнное присоедиение, отпрака, и отсоединение. С уже присоединённым будет только отправка.

11) Преобразования имён и адресов
    
11.1) Введение
    gethostbyname и gethostbyaddr - для преобразования имён узлов и IP-падресов
    getservbyname и getservbyport - для преобразования имён служб и номеров портов
    getaddrinfo и getnameinfo - преобразования между IP-адресами и именами узлов, а также
        между именами служб и номерами портов. Они независимы от протокола

11.2) Система доменных имён
    Domain Name System, DNS - используется для сопоставления имён улов и IP-адресов.
    Имя может быть простым (simple name): solaris, bsdi, либо 
    полным доменным именем (fully qualified domain name, FQDN): solaris.unpbook.com

    Записи ресурсов (resource records, RR):
        A    - преобр. имя узла в  32-разрядный адрес IPv4
        AAAA - преобр. имя узла в 128-разрядный адрес IPv6
        PTR (pointer records) - преобр. IP-адрес в имя узла
        MX (Mail Exchange Record) - опред., что узел выступает в роли "маршрутизирующего 
            почтового сервер" для заданного узла.
        CNAME (canonical name) - обычно такие записи исп. для присовения имён распростр.
            службам, таким как ftp и www.

    Сервер имён. Часто используется BIND.
    Приложения (клиенты и серверы) соед. с серевром DNS при помощи вызова функции из 
    библиотеки, назыв. распознователем (resolver):
        gethostbyname - находит адрес узла по имени
        gethostbyaddr - находит имя по адресу узла

    /etc/resolv.conf - обычно содержит IP-адреса локальных серверов имён

    Альтернативы DNS:
        /etc/hosts
        
